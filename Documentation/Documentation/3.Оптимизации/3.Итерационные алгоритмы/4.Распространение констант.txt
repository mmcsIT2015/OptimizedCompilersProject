__Постановка задачи__

Межблочное распространение констант.
Задача распространения констант состоит в передаче информации о текущем значении переменных в следующие блоки. Если на каком-либо 
участке кода переменная принимает одинаковые значения для всех путей графа потока, то алгоритм должен заменить ее вхождения 
в правой части выражений на константу.

__Вход__

Трехадресный код

__Выход__

Трехадресный код, с примененной оптимизацией

__Описание алгоритма__

Оптимизация состоит из следующих шагов:

1. Анализ значений всех переменных в левых частях выражений для каждого блока. 
	
2. Оптимизация с использованием информации, полученной на шаге 1.

Алгоритм выполняется до тех пор, пока в коде что-то меняется. 
 
__Подробное описание шагов алгоритма__

__1. Анализ значений переменных.__
__Вход__
Трехадресный код

__Выход__
Список множеств ConstNACinfo для каждого блока

__Описание шага 1__

Класс ConstNACinfo содержит в себе 3 поля Type, VName, Value.

Перечислимый тип VariableConstType содержит в себе 3 значения: UNDEFINED, CONSTANT, NOT_A_CONSTANT

VarType - поле перечислимого типа VariableConstType, содержит информацию о состоянии переменной(не определена, константа, не константа)
VarName - имя переменной
ConstVal - значение переменной, если она является константой.

Метод MaxLowerBound, возвращающий своего рода наибольшую нижнию границу для двух экземпляров класса ConstNACinfo.

Определим: c1 = v1.ConstVal, c2 = v2.ConstVal, c1 != c2;

Тогда результат выполнения метода будет следущим:
 
v1.VarType\v2.VarType|UNDEF| c2  | NAC |
     UNDEF           |UNDEF| c2  | NAC |
      c1             | c1  | NAC | NAC |
	  NAC            | NAC | NAC | NAC |

Если же c1 = c2, то:	  
v1.VarType\v2.VarType|UNDEF| c2  | NAC |
     UNDEF           |UNDEF| c2  | NAC |
      c1             | c1  | c1  | NAC |
	  NAC            | NAC | NAC | NAC |
	  
Определим `IN[B]` как множество  ConstNACinfo, непосредственно перед блоком `B`, `OUT[B]` - как такое же множество в точке, следующей 
сразу за блоком `B`. 

Пусть `GEN[B]` - множество, состоящее из ConstNACinfo (тип, переменная, значение) для каждой переменной из левых частей выражений 
блока `B`. В нем учитываются результаты последних присваиваний для каждой из переменных `x`. Если присваивание имеет вид: 
`x=<константа>`, то переменная`x` во множестве `GEN[B]` помечается, как `CONSTANT`, иначе - `NOT_A_CONSTANT`.

Генерация данного множества для каждого из блоков представлена вызовом метода класса  ThreeAddrCode `GetConstInfo()`, 
возвращающего `List<HashSet<ConstNACinfo>>`	

Определим `join_operator` как оператор на множестве ConstNACinfo:
    `X <join_operator> (Y) = X <объединение, которое при совпадении имен берет результат работы MaxLowerBound> (Y)`
	где `Z`  множество элементов `y` из `Y`: существует `x` из `X`: `y`.VarName = `x`.VarName.  
	
Определим `operator` как оператор на множестве ConstNACinfo:
    `X <operator> (Y) = X <объединение> (Y - Z)`
	где `Z`  множество элементов `y` из `Y`: существует `x` из `X`: `y`.VarName = `x`.VarName.  

Тогда уравнения, связывающее `GEN[B]`, `OUT[B]` и `IN[B]` выглядят следующим образом:

```
	IN[B] = <join_operator по P - непосредственным предкам B>OUT[P]
	OUT[B] = GEN[B]<operator>(IN[B])
```


Реализация включает обобщенный итерационный алгоритм, реализующий описанные уравнения и возвращающий множества 
`IN` и `OUT` для каждого блока трехадресного кода.
для проверки полученных множеств можно использовать `TestConstantsPropagation_sets(ProgramTree.BlockNode root)`

__Шаг 2 оптимизации__

__Вход__

Трехадресный код, множество `ConstNACinfo` для каждого блока.

__Выход__

трехадресный код, в котором протянуты и свернуты все известные константы

__Описание__

В начало каждого блока дописываются все известные для этого блока константы, выполняются оптимизации протяжки 
и сворачивания констант внутри блока. Затем удаляются добавленные строки.

алгоритм распространения констант завершается, если после шага 2 код не изменился

__Тестирование оптимизации распространения констант__
В проекте реализован класс `ConstantsPropagationOptimization` - наследник  `IOptimizer`.
Для его работы необходимо передать ему трехадресный код
~~~~~~{.cs}
ConstantsPropagationOptimization opt = new ConstantsPropagationOptimization(code);
opt.Optimize();
~~~~~~

__Пример оптимизации__

Начальный код:

{
    int x = 0;
	int y = 0;
	int z = 0;
    int p = 5;
    y = 3;
    while (x == 5)
    {
        x = p + 4;
        p = 7;
        while (p == 5)
        {
            y = x + y;
            z = p + 1;		
        }
        p = 5;
    }
}

Преобразованный код:

{
    int x = 0;
	int y = 0;
	int z = 0;
    int p = 5;
    y = 3;
    while (x == 5)
    {
        x = 9;
        p = 7;
        while (7 == 5)
        {
            y = 9 + y;
            z = 8;		
        }
        p = 5;
    }
}