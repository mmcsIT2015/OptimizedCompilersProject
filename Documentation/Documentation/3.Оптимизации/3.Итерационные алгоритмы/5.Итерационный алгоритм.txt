# Итерационный алгоритм

Как общеизвестно, итерационный алгоритм для каждого вида оптимизаций имеет похожий вид - различаются лишь конкретные участки. Общая схема этого алгоритма (в видепсевдокода) приведена ниже.

```
OUT[Вход] = <пустое-множество>
Для всех базовых блоков B, кроме `Вход`
  OUT[B] = <верхний-элемент>

Пока OUT[B] по всем базовым блокам B меняются
  Для всех базовых блоков B
    IN[B] = <oператор-сбора> по OUT[P] для всех P - предш. B
    OUT[B] = <передаточная-функция>(IN[B])
```

Верхний элемент и оператор сбора (плюс направление анализа потока данных и область определения) образуют т.н. `полурешетку`.

Таким образом можно написать обобщенную версию итерационного алгоритма, параметрами которого будут `полурешетка` и `семейство передаточных функций`.

#### Реализация обобщенного алгоритма

~~~~~~{.cs}
class IterativeAlgo<AData, TrFunc>
    where TrFunc : ITransferFunction<AData>
{
  public ISemilattice<AData> Semilattice; // полурешетка
  public Dictionary<Block, TrFunc> TransferFuncs; // передаточные функции

  public void Run(ThreeAddrCode code);
  public void RunOnReverseGraph(ThreeAddrCode code);
~~~~~~

Здесь `Semilattice` - полурешетка для типа `AData` (т.е. верхний элемент и оператор сбора для этого типа), `TransferFuncs` - набор передаточных функций для каждого базового блока кода.

Функции `Run` и `RunOnReverseGraph` запускают итерационный алгоритм в прямом (сверху вниз) и обратном (снизу вверх) направлениях анализа соответственно.

Стоит отметить, что в рамках курса разработаны варианты полурешеток для различных алгоритмов (к примеру, `IntersectSemilattice`, верхним элементом которой является множество всех значений типа, а оператором сбора - пересечение, или `UnionSemilattice` с верхним элементом - пустым множеством и оператором сбора объединением), а в статическом классе `TransferFuncFactory` можно найти функции для получения семейств передаточных функций для различных типов.

И для полурешеток, и для передаточных функций созданы интерфейся, которые упомятуные ваше экземпляры и реализуют.

~~~~~~{.cs}
interface ISemilattice<T> {
  IEnumerable<T> Join(IEnumerable<T> lhs, IEnumerable<T> rhs); // оператор сбора
  IEnumerable<T> Top(); // T - верхний элемент
}
~~~~~~

~~~~~~{.cs}
public interface ITransferFunction<T> {
  IEnumerable<T> Map(IEnumerable<T> x);
  ITransferFunction<T> Map(ITransferFunction<T> f1); // композиция передат-х ф-й
}
~~~~~~

#### Обратное направление анализа

Как было замечено выше, общая схема итерационного алгоритма однотипна, как для различных оптимизаций - так и для направления обхода графа. Ниже представлена схема алгоритма для обратного направления анализа.

```
IN[Выход] = <пустое-множество>
Для всех базовых блоков B, кроме `Выход`
  IN[B] = <верхний-элемент>

Пока IN[B] по всем базовым блокам B меняются
  Для всех базовых блоков B
    OUT[B] = <oператор-сбора> по OUT[P] для всех P - потомков B
    IN[B] = <передаточная-функция>(OUT[B])
```

Для того, чтобы реализовать возможность анализа с помощью итерационного алгоритма в обратном направлении, используя имеющиеся наработки, было решено просто на вход в этом случае подавать инвертированный граф. Кроме того, после выполнения алгоритма множества IN и OUT меняются местами (учитывая схему алгоритма при обратном обходе).

Запустить алгоритм в обратном направлении анализа можно с помощью функции `RunOnReverseGraph(code)` основного класса `IterativeAlgo`.
