__Общая концепция__

Для обхода синтаксического дерева было решено использовать паттерн _Посетитель_ (Visitor). Интерфейс для него имеет следующий вид:

~~~~~~~{.cs}
public interface IVisitor {
  void Visit(BlockNode node);
  void Visit(WhileNode node);
  void Visit(OtherTreeNode node);
  ...
}
~~~~~~~

Количество функций `Visit(..)` этого интерфейса должно покрывать все имеющиеся в дереве узлы.

> `BlockNode` является корнем синтаксического дерева, и обход начитается именно с него.

Каждый класс-посетитель дерева должен реализовывать представленный выше интерфейс.

__Реализация генератора кода__

~~~~~~~{.cs}
public class Gen3AddrCodeVisitor : IVisitor {
  public iCompiler.ThreeAddrCode CreateCode();
  ...
}
~~~~~~~

В качестве вспомогательной структуры для генерации кода при обходе дерева используется стэк. Запуск обхода происходит путем вызова функции

~~~~~~{.cs}
  public void Visit(BlockNode root);
~~~~~~

аргументом которой является корень сгенерирвоанного ранее синтаксического дерева.

> Функции, реализующие обход различных узлов дерева, особого интереса не представляют, и поэтому их описание опускается.

После выполнения обхода всего дерева можно получить трехадресный код с помощью функции ```CreateCode()```. При каждом вызове этой функции будет сгенерирован новый экземпляр трехадресного кода (т.е. в визиторе хранятся лишь данные, которые могут быть использованы для этой генерации).

__Вывод типов__

Типизация переменных происходит в два этапа.

На первом этапе - собственно обход дерева - определяются типы для пользовательских переменных, исходя из их объявления. При попытке использовать пользовательскую переменную, которая не объявлена, выбрасывается исключение (`SemanticException`).

Второй этап происходит после обхода при запросе у визитора трехадресного кода.
Выполняется обход имеющегося трехадресного кода, и для временных переменных, тип которых еще не определен, он определяется по следующим правилам:
- Всем временным переменным, участвующим в `if`, `while` и т.п. - т.е. являющихся условиями - назначается тип `bool`
- Для всех остальных возможных конструкций (унарных операторов, бинарных операторов или тождеств) тип переменной в левой части выводится исходя из таблицы приведения типов. В подобных конструкциях в парвой части на данном этапе будут участвовать либо переменные, тип которых уже определен (либо на первом этапе, либо ранее на этом же), либо числовые значения - в этом случае сперва выполняется попытка преобразовать это числовое значение в тип `int`, и лишь в случае невозможности такого приведения переменной назначается тип float

> Приоритеты типизации: `int` > `float`; `bool` находится несколько особняком

В случае выполнения арифметической операции над переменными разных типов происходит приведение типов к наиболее подходящему (к примеру, ```<int> + <float> -> <float>```). Ниже приведена таблица приведения типов (в левой колонке и верхнем ряду - типы операндов бинарного оператора)

| | float | int | bool
|:---:|:---:|:---:|:---:
| __float__ | float | float | bool
| __int__  | float | int | bool
| __bool__ | bool | bool | bool

__Пример использования__

~~~~~~{.cs}
try {
  BlockNode root = FileLoader.LoadFile(file, System.Text.Encoding.UTF8);
  var generator = new Gen3AddrCodeVisitor();
  generator.Visit(root);

  var code = generator.CreateCode();
}
catch (FileNotFoundException) {
  Console.WriteLine("File not found: " + file);
}
catch (LexException e) {
  Console.WriteLine("Lexer error: " + e.Message);
}
catch (SyntaxException e) {
  Console.WriteLine("Syntax error: " + e.Message);
}
catch (SemanticException e) {
  Console.WriteLine("Semantic error: " + e.Message);
}
~~~~~~
