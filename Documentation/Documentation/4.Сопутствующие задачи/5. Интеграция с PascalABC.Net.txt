Суть интеграции заключалась в том, чтобы реализовать возможность преобразования синтаксического дерева __PascalABC.Net__ в трехадресный код, выполнении оптимизаций над этим трехадресным кодом и обратной конвертации преобразованного трехадресного кода в синтаксическое дерево __PascalABC.Net__.

Предварительно синтаксичческое дерево подвергается так называемому lowering'у - замене высокоуровневых конструкций типа `while`, `repeat` и т.п. на простые конструкции, содержащие лишь операторы `goto`. Сложных `if` (к примеру, содержащие много строк в теле `then` или `else`) также упрощаются.

Для выполнения поставленной задачи было реализовано два класса - генератор трехадресного кода и генератор синтааксического дерева `PascalABC.Net`.

__Реализация__

Для генерации трехадресного кода из синтаксического дерева используется класс

~~~~~~{.cs}
class Gen3AddrCodeVisitor : WalkingVisitorNew {
  public iCompiler.ThreeAddrCode CreateCode();
}
~~~~~~

Метод `CreateCode();` генерирует трехадресный код (который и возвращает) из данных, полученных в процессе выполнения обхода дерева. Также именно в этой функции создается таблица имен.


Для генерации синтаксического дерева из трехадресного кода реализован класс `PascalABCTreeGenerator`:
~~~~~~{.cs}
public class PascalABCTreeGenerator {
  public block Generate(iCompiler.ThreeAddrCode code);
}
~~~~~~

Стоит отметить, что при использовании делегата `compiler.SyntaxTreeChanger`, который и выполняет преобразование над синтаксическим деревом, для корректного использования вышеописанного генератора синтаксического дерева, последовательность действий внутри основной функции `Change(..)` этого делегата должна быть следующей:

~~~~~~{.cs}
public class SyntaxTreeChanger : ISyntaxTreeChanger {
  public void Change(syntax_tree_node sn) {
    sn.visit(new LoweringVisitor());
    ...
    var visitor = new Gen3AddrCodeVisitor();
    sn.visit(visitor);

    try {
      Code = generator.CreateCode();
      ...
      // тут выполняем оптимизации, если необходимо
      ...
      var generator = new PascalABCTreeGenerator();
      var program_block = generator.Generate(Code);
      (sn as program_module).program_block = program_block;
      ...
    }
  }
}
~~~~~~

__Нереализованные возможности__

В настоящий момент трехадресный код преобразуется в синтаксическое дерево "как есть". В процессе разработки была идея реализовать сворачивание трехадресных выражений в полное выражение; например, преобразовать

```
@t1 = 2 + 3
a = 2*@t1
```
в
```
a = 2 * (2+3)
```

и уже выражение в таком виде помещать в синтаксическое дерево. Необходимый функционал был реализован. Однако позже мы пришли к выводу, что в процессе оптимизаций строка ```@t1 = 2 + 3```, которую после подобного сворачивания нужно было удалить (чтобы не проводить лишних вычислений), может быть использована кодом ниже, и подобное удаление не возможно. Это лишь часть из проблем, с которыми мы столкнулись при решении этой задачи.

Таким образом, задача по подобным преобразованиям является не такой уж и тривиальной, и от нее было решено отказаться по причине наличия более приоритетных задач.

__Заключение__

Генерация трехадресного кода поддерживает стандартные синтаксические конструкции (if, while, repeat, for) и вызовы функций (к примеру, write/writeln/read/readln).

Для тестирования результатов оптимизаций в GUI данного проекта есть возможность загрузить код в файле `.pas` и увидеть скорость работы оптимизированного и неоптимизированного вариантов.
