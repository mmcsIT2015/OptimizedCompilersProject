# 1 Введение

# 2 Описания языков программирования
## 2.1 C-подобная грамматика

## 2.2 Pascal-подобная грамматика

# 3 Оптимизации
## 3.1 В пределах базового блока
### 3.1.1 Def-Use информация о переменных

### 3.1.2 Устранение мертвого кода

### 3.1.3 Свертка констант и алгебраические тождества

### 3.1.4 Оптимизация общих подвыражений

### 3.1.5 Протяжка констант

### 3.1.6 Генерация 3-х адресного кода

### 3.1.7 Выделение базовых блоков

## 3.2 Построение графа потока управления

## 3.3 Итерационные алгоритмы
### 3.3.1 Достигающие определения
#### 3.3.1.1 Вычисление множеств gen и kill

#### 3.3.1.2 Реализация передаточной функции
##### 3.3.1.2.1 Суперозиция передаточных функций команд

##### 3.3.1.2.2 Общая формула

#### 3.3.1.3 Реализация алгоритма

#### 3.3.1.4 Тесты

### 3.3.2 Активные переменные
#### 3.3.2.1 Анализ

#### 3.3.2.2 Набор тестов

#### 3.3.2.3 Оптимизации

### 3.3.3 Доступные выражения
#### 3.3.3.1 Анализ

#### 3.3.3.2 Набор тестов

#### 3.3.3.3 Оптимизации

### 3.3.4 Распространение констант

### 3.3.5 Объединение итерационных алгоритмов

### 3.3.6 Отношение доминирования
#### 3.3.6.1 Итерационный алгоритм

#### 3.3.6.2 Построения графа доминатора

### 3.3.7 Изменение итерационного алгоритма

## 3.4 Анализ графа для алгоритма выделения областей
### 3.4.1 Обход в глубину с нумерацией

### 3.4.2 Построение остовного дерева

### 3.4.3 Классификация рёбер

### 3.4.4 Определить обратные рёбра в CFG

### 3.4.5 Определить приводимость графа

### 3.4.6 Определение всех естественных циклов
__Постановка задачи__

Определение всех естественных циклов

__От каких задач зависит(на каких задачах основывается), входные данные__

На вход алгоритму подаются:

- Список базовых блоков 

~~~~~~~{.cs}

    IEnumerable<T> blocks

~~~~~~~~~~~~~~

- Граф потока управления

~~~~~~~{.cs}

    IGraph<T> graph

~~~~~~~~~~~~~~~

- Список обратных дуг

~~~~~~~{.cs}

    List<DomGraph.ValPair<T>> reverseEdges

~~~~~~~~~~~~~~

- Дерево доминатора

~~~~~~~{.cs}

    IDominatorRelation<T>

~~~~~~~~~~~~~~

Данный алгоритм основывается на задачах, которые занимаются построением соотвествующих структур данных,
за исключением IDominatorRelation<T>, который предоставляется как интерфейс:

~~~~~~~{.cs}

    /// <summary>
    /// Интерфейс для дерева доминатора
    /// </summary>
    /// <typeparam name="T">Тип данных</typeparam>
    public interface IDominatorRelation<T>
    {
        /// <summary>
        /// Отношение доминирования первой вершины над второй
        /// </summary>
        /// <param name="a">Первая вершина</param>
        /// <param name="b">Вторая вершина</param>
        /// <returns></returns>
        bool FirstDomSeccond(T a, T b);

        /// <summary>
        /// Все вершины, которые доминируют над текущей
        /// </summary>
        /// <param name="a">Вершина</param>
        /// <returns></returns>
        IEnumerable<T> UpperDominators(T a);
    }

~~~~~~~~~~~~~~~~

__Для каких задач нужна(для каких задач является основой), выходные данные__

Выходные данные алгоритма - список циклов:

~~~~~~~{.cs}

    List<Cycle>

~~~~~~~~~~~~~~~~

Данная задача является основой для задачи "Определение вложенности естественных циклов"

__Реализация(интерфейс т.е. классы, методы)__

Шаблон типа необходим для проведения тестирования алгоритма с помощью типа int, но алгоритм предназначен для использования с типом Block.

Данный алгоритм реализуется классами:

1. AllCycles< T > - находит все циклы типа CycleUsual<T> (цикл типа CycleSpecialCase<T> распознается как 2 цикла типа CycleUsual<T>)

~~~~~~~{.cs}

    public class AllCycles<T> where T : IComparable<T>
    { 
         public List<Cycle<T>> cycles { get; protected set; } 
         public AllCycles(IEnumerable<T> blocks, IGraph<T> graph, 
         List<DomGraph.ValPair<T>> reverseEdges, 
  			    IDominatorRelation<T> domTree);
    }

~~~~~~~~~~~~~~

2. AllCyclesSpecialCase< T > - находит все циклы типа CycleUsual<T> и CycleSpecialCase<T>

~~~~~~~{.cs}

    public class AllCyclesWithSpecialCase<T> : AllCycles<T>  
    where T: IComparable<T>
    {
         public AllCyclesWithSpecialCase(IEnumerable<T> blocks, 
				    IGraph<T> graph, 
         List<DomGraph.ValPair<T>> reverseEdges, 
			    IDominatorRelation<T> domTree);
    }

~~~~~~~~~~~~~~

Тип Cycle< T > является абстрактным классом цикла, который реализуется 2 классами:

~~~~~~~{.cs}

    /// <summary>
    /// Класс цикла
    /// </summary>
    /// <typeparam name="T">Тип вершин</typeparam>
    public abstract class Cycle<T>
    {
        /// <summary>
        /// Вход в цикл
        /// </summary>
        public T N { get; set; }

        /// <summary>
        /// Все вершины, принадлежащие циклу
        /// </summary>
        public List<T> DATA { get; set; }

        /// <summary>
        /// Ребра - выходы из цикла
        /// </summary>
        public List<DomGraph.ValPair<T>> OUTS { get; set; }
    }

    /// <summary>
    /// Цикл с одной обратной дугой
    /// </summary>
    /// <typeparam name="T">Тип вершин</typeparam>
    public class CycleUsual<T>: Cycle<T>
    {
        public CycleUsual(T n, List<T> data, 
         	    List<DomGraph.ValPair<T>> outs, T d)
        {
            this.N = n;
            this.DATA = data;
            this.OUTS = outs;
            this.D = d;
        }

        /// <summary>
        /// Вершина из обратного ребра
        /// </summary>
        public T D { get; set; }
    }

    /// <summary>
    /// Цикл с двумя обратными дугами
    /// </summary>
    /// <typeparam name="T">Тип вершин</typeparam>
    public class CycleSpecialCase<T> : Cycle<T>
    {
        public CycleSpecialCase(T n, List<T> data, 
  	    List<DomGraph.ValPair<T>> outs, T d1, T d2)
        {
            this.N = n;
            this.DATA = data;
            this.OUTS = outs;
            this.D1 = d1;
            this.D2 = d2;
        }

        /// <summary>
        /// Вершина из первого обратного ребра
        /// </summary>
        public T D1 { get; set; }

        /// <summary>
        /// Вершина из второго обратного ребра
        /// </summary>
        public T D2 { get; set; }
    }

~~~~~~~~~~~~~~

Других видов циклов не бывает.	
List< Cycle< T > > - полиморфный контейнер, который хранит в себе 2 вида циклов.

__Пример использования:__

~~~~~~~{.cs}

    //Входные данные
    List<Block> block;
    ControlFlowGraph graph;
    List<DomGraph.ValPair<Block>> reverseEdges;
    DomTree domTree;
    //...
    //Инициализация
    AllCycles<Block> allCyclesSpec = 
	    new AllCyclesWithSpecialCase<Block>(blocks, graph, 
				    reverseEdges, domTree);
    AllCycles<Block> allCycles = 
	    new AllCycles<Block>(code.blocks, code.graph, 
			    reverseEdges, domTree);
    //Получить все циклы с учётом "специального случая"
    List<Cycle<Block>> cyclesSpec = allCycles.cycles;
    //Получить все циклы без учёта "специального случая"
    List<Cycle<Block>> cycles = allCycles.cycles;

~~~~~~~~~~~~~~
	
__Описание(что делает и как реализовано)__

- Алгоритм ищет все циклы в графе потока управления.

- Считает граф потока управления приводимым.

- Ищет все циклы в графе вне зависимости от их вложенности.

- Алгоритм раелизован с помощью рекурсивного обхода вглубину по напрвлению дуг, обратных графу потока управления. Обход начинается с каждой точки выхода из цикла, и заканчивается обходом всего цикла.

	
__Тесты(если есть и если не являются другой задачей)__

Тестовые структуры данных, реализующие соответствующие интерфейсы, а также классы примеров вы можете видеть на dgml диаграмме (см. рис. 1)

![Рис. 1](dgml1.jpg "Рис. 1")
Рис. 1
  
Для прогона тестов необходимо вызвать 

~~~~~~~{.cs}

    AllCyclesTesting.TestingAllCycles();

~~~~~~~~~~~~~~
__Команда__
Альфа

### 3.4.7 Вложенность естественных циклов

### 3.4.8 Глубина CFG

## 3.5 Алгоритм выделения областей
### 3.5.1 Выделение областей

### 3.5.2 Реализация алгоритма на основе областей

# 4 Сопутствующие задачи
## 4.1 GUI

## 4.2 Генерация IL-кода

## 4.3 Документация

## 4.4 Подсчёт статистики

# 5 Заключение

