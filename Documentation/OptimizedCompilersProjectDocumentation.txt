# 1 Введение

# 2 Описания языков программирования
## 2.1 C-подобная грамматика
Реализовано:
Циклы (do-while, while), ветвления(if-else), вызовы функций (грамматика самих функций не написана), cout, определение переменных с заданием типа(в одной строке в том числе), грамматика выражений.
Циклов for и операций ++ и ей подобных нет.

Данный пример покажет доступные возможности грамматики С.

~~~~~~~{.cs}
{
	int a = 1, b = 3 * (2 + a);
	cout << 1 << a << endl << 3 << endl;
	some_function_call(a, b, 4);
	while(a < b)
	{
		do
		{
			if (a > 3)
				a = a + 1;
			else a = a - 1;
		}
		while(b < a);
	}
}
~~~~~~~~~~~~~~~

## 2.2 Pascal-подобная грамматика

# 3 Оптимизации
## 3.1 В пределах базового блока
### 3.1.1 Def-Use информация о переменных
__Постановка задачи__

Вычисление Def-Use информации о переменных внутри базового блока.

__Вход__

0. Трехадресный код.
1. Задача решена с помощью метода класса Block, он должен быть создан.
2. Номер строки трехадресного кода.

__Выход__

1. Возвращает список живых переменных на данной строке
2. Проверяет, жива ли переменная на данной строке

__Описание алгоритма__

Анализ представлен тремя методами класса Block:

1. `void CalculateDefUseData()`, проходящую по всем строкам 3-х адресного кода данного блока и заполняющую внутреннюю структуру живыми переменными для каждой строки 3-х адресного кода. Метод должен вызываться перед первым вызовом `IsVariableAlive`, `GetAliveVariables`, также требуется повторный вызов, если блок был изменен.

2. `bool IsVariableAlive(string variable, int step)`, возвращает false, если переменная мертва на данном шаге, в противном случае 1.

3. `HashSet<string> GetAliveVariables(int step)`, возвращает множество живых переменных для заданного шага.

__Пример использования__

~~~~~~~{.cs}
		block.CalculateDefUseData();
		Hashset<string> alive_vars = block.GetAliveVariables(current_line);
		bool is_alive_a = block.IsVariableAlive("a", current_line);
~~~~~~~~~~~~~~~

### 3.1.2 Устранение мертвого кода

### 3.1.3 Свертка констант и алгебраические тождества

### 3.1.4 Оптимизация общих подвыражений

### 3.1.5 Протяжка констант

### 3.1.6 Генерация 3-х адресного кода

### 3.1.7 Выделение базовых блоков

## 3.2 Построение графа потока управления

## 3.3 Итерационные алгоритмы
### 3.3.1 Достигающие определения
#### 3.3.1.1 Вычисление множеств gen и kill
__Постановка задачи__

Генерация Gen-Kill множеств для достигающих определений

__Вход__

Трехадресный код.

__Выход__

Список множеств Gen и Kill для каждого блока.

__Описание алгоритма__

Генерация представлена вызовом метода класса ThreeAddrCode `GetGenKillInfoData()`, возвращающего `List<GenKillInfo>`.
Каждый элемент списка представляет собой множества Gen и Kill для соответствующего блока.

Класс `GenKillInfo` содержит два поля `HashSet<Index>` с именами `Gen` и `Kill`, представляющие соответствующие множества для блока.

Класс Index содержит информацию о переменной из множеств `Gen-Kill`, содержит поля `int mBlockInd` с номером блока,
`int mInternalInd` - номер строки в блоке, `mVariableName` - имя переменной.


__Пример использования__

~~~~~~~{.cs}
   Console.WriteLine("GenKillInfo");
   var a = codeGenerator.Code.GetGenKillInfoData();
   for (int i = 0; i < a.Count; ++i)
   {
		Console.WriteLine("Block: " + i);
		Console.WriteLine("Gen");
		foreach (ThreeAddrCode.Index ind in a[i].Gen)
			Console.WriteLine(ind.ToString());
			Console.WriteLine("Kill");
			foreach (ThreeAddrCode.Index ind in a[i].Kill) {
				Console.WriteLine(ind.ToString());
			}
			Console.WriteLine();
   }
~~~~~~~~~~~~~~~

#### 3.3.1.2 Реализация передаточной функции
##### 3.3.1.2.1 Суперозиция передаточных функций команд

##### 3.3.1.2.2 Общая формула

#### 3.3.1.3 Реализация алгоритма

#### 3.3.1.4 Тесты

### 3.3.2 Активные переменные
#### 3.3.2.1 Анализ

#### 3.3.2.2 Набор тестов

#### 3.3.2.3 Оптимизации

### 3.3.3 Доступные выражения
#### 3.3.3.1 Анализ

#### 3.3.3.2 Набор тестов

#### 3.3.3.3 Оптимизации

### 3.3.4 Распространение констант

### 3.3.5 Объединение итерационных алгоритмов

### 3.3.6 Отношение доминирования
#### 3.3.6.1 Итерационный алгоритм

#### 3.3.6.2 Построения графа доминатора

### 3.3.7 Изменение итерационного алгоритма

## 3.4 Анализ графа для алгоритма выделения областей
### 3.4.1 Обход в глубину с нумерацией

### 3.4.2 Построение остовного дерева

### 3.4.3 Классификация рёбер

### 3.4.4 Определить обратные рёбра в CFG

### 3.4.5 Определить приводимость графа

### 3.4.6 Определение всех естественных циклов
__Постановка задачи__

Определение всех естественных циклов

__От каких задач зависит(на каких задачах основывается), входные данные__

На вход алгоритму подаются:

- Список базовых блоков 

~~~~~~~{.cs}

    IEnumerable<T> blocks

~~~~~~~~~~~~~~

- Граф потока управления

~~~~~~~{.cs}

    IGraph<T> graph

~~~~~~~~~~~~~~~

- Список обратных дуг

~~~~~~~{.cs}

    List<DomGraph.ValPair<T>> reverseEdges

~~~~~~~~~~~~~~

- Дерево доминатора

~~~~~~~{.cs}

    IDominatorRelation<T>

~~~~~~~~~~~~~~

Данный алгоритм основывается на задачах, которые занимаются построением соотвествующих структур данных,
за исключением IDominatorRelation<T>, который предоставляется как интерфейс:

~~~~~~~{.cs}

    /// <summary>
    /// Интерфейс для дерева доминатора
    /// </summary>
    /// <typeparam name="T">Тип данных</typeparam>
    public interface IDominatorRelation<T>
    {
        /// <summary>
        /// Отношение доминирования первой вершины над второй
        /// </summary>
        /// <param name="a">Первая вершина</param>
        /// <param name="b">Вторая вершина</param>
        /// <returns></returns>
        bool FirstDomSeccond(T a, T b);

        /// <summary>
        /// Все вершины, которые доминируют над текущей
        /// </summary>
        /// <param name="a">Вершина</param>
        /// <returns></returns>
        IEnumerable<T> UpperDominators(T a);
    }

~~~~~~~~~~~~~~~~

__Для каких задач нужна(для каких задач является основой), выходные данные__

Выходные данные алгоритма - список циклов:

~~~~~~~{.cs}

    List<Cycle>

~~~~~~~~~~~~~~~~

Данная задача является основой для задачи "Определение вложенности естественных циклов"

__Реализация(интерфейс т.е. классы, методы)__

Шаблон типа необходим для проведения тестирования алгоритма с помощью типа int, но алгоритм предназначен для использования с типом Block.

Данный алгоритм реализуется классами:

1. AllCycles< T > - находит все циклы типа CycleUsual<T> (цикл типа CycleSpecialCase<T> распознается как 2 цикла типа CycleUsual<T>)

~~~~~~~{.cs}

    public class AllCycles<T> where T : IComparable<T>
    { 
         public List<Cycle<T>> cycles { get; protected set; } 
         public AllCycles(IEnumerable<T> blocks, IGraph<T> graph, 
         List<DomGraph.ValPair<T>> reverseEdges, 
  			    IDominatorRelation<T> domTree);
    }

~~~~~~~~~~~~~~

2. AllCyclesSpecialCase< T > - находит все циклы типа CycleUsual<T> и CycleSpecialCase<T>

~~~~~~~{.cs}

    public class AllCyclesWithSpecialCase<T> : AllCycles<T>  
    where T: IComparable<T>
    {
         public AllCyclesWithSpecialCase(IEnumerable<T> blocks, 
				    IGraph<T> graph, 
         List<DomGraph.ValPair<T>> reverseEdges, 
			    IDominatorRelation<T> domTree);
    }

~~~~~~~~~~~~~~

Тип Cycle< T > является абстрактным классом цикла, который реализуется 2 классами:

~~~~~~~{.cs}

    /// <summary>
    /// Класс цикла
    /// </summary>
    /// <typeparam name="T">Тип вершин</typeparam>
    public abstract class Cycle<T>
    {
        /// <summary>
        /// Вход в цикл
        /// </summary>
        public T N { get; set; }

        /// <summary>
        /// Все вершины, принадлежащие циклу
        /// </summary>
        public List<T> DATA { get; set; }

        /// <summary>
        /// Ребра - выходы из цикла
        /// </summary>
        public List<DomGraph.ValPair<T>> OUTS { get; set; }
    }

    /// <summary>
    /// Цикл с одной обратной дугой
    /// </summary>
    /// <typeparam name="T">Тип вершин</typeparam>
    public class CycleUsual<T>: Cycle<T>
    {
        public CycleUsual(T n, List<T> data, 
         	    List<DomGraph.ValPair<T>> outs, T d)
        {
            this.N = n;
            this.DATA = data;
            this.OUTS = outs;
            this.D = d;
        }

        /// <summary>
        /// Вершина из обратного ребра
        /// </summary>
        public T D { get; set; }
    }

    /// <summary>
    /// Цикл с двумя обратными дугами
    /// </summary>
    /// <typeparam name="T">Тип вершин</typeparam>
    public class CycleSpecialCase<T> : Cycle<T>
    {
        public CycleSpecialCase(T n, List<T> data, 
  	    List<DomGraph.ValPair<T>> outs, T d1, T d2)
        {
            this.N = n;
            this.DATA = data;
            this.OUTS = outs;
            this.D1 = d1;
            this.D2 = d2;
        }

        /// <summary>
        /// Вершина из первого обратного ребра
        /// </summary>
        public T D1 { get; set; }

        /// <summary>
        /// Вершина из второго обратного ребра
        /// </summary>
        public T D2 { get; set; }
    }

~~~~~~~~~~~~~~

Других видов циклов не бывает.	
List< Cycle< T > > - полиморфный контейнер, который хранит в себе 2 вида циклов.

__Пример использования:__

~~~~~~~{.cs}

    //Входные данные
    List<Block> block;
    ControlFlowGraph graph;
    List<DomGraph.ValPair<Block>> reverseEdges;
    DomTree domTree;
    //...
    //Инициализация
    AllCycles<Block> allCyclesSpec = 
	    new AllCyclesWithSpecialCase<Block>(blocks, graph, 
				    reverseEdges, domTree);
    AllCycles<Block> allCycles = 
	    new AllCycles<Block>(code.blocks, code.graph, 
			    reverseEdges, domTree);
    //Получить все циклы с учётом "специального случая"
    List<Cycle<Block>> cyclesSpec = allCycles.cycles;
    //Получить все циклы без учёта "специального случая"
    List<Cycle<Block>> cycles = allCycles.cycles;

~~~~~~~~~~~~~~
	
__Описание(что делает и как реализовано)__

- Алгоритм ищет все циклы в графе потока управления.

- Считает граф потока управления приводимым.

- Ищет все циклы в графе вне зависимости от их вложенности.

- Алгоритм раелизован с помощью рекурсивного обхода вглубину по напрвлению дуг, обратных графу потока управления. Обход начинается с каждой точки выхода из цикла, и заканчивается обходом всего цикла.

	
__Тесты(если есть и если не являются другой задачей)__

Тестовые структуры данных, реализующие соответствующие интерфейсы, а также классы примеров вы можете видеть на dgml диаграмме (см. рис. 1)

![Рис. 1](dgml1.jpg "Рис. 1")
Рис. 1
  
Для прогона тестов необходимо вызвать 

~~~~~~~{.cs}

    AllCyclesTesting.TestingAllCycles();

~~~~~~~~~~~~~~
__Команда__
Альфа

### 3.4.7 Вложенность естественных циклов

### 3.4.8 Глубина CFG

## 3.5 Алгоритм выделения областей
### 3.5.1 Выделение областей

### 3.5.2 Реализация алгоритма на основе областей

# 4 Сопутствующие задачи
## 4.1 GUI

## 4.2 Генерация IL-кода

## 4.3 Документация

## 4.4 Подсчёт статистики

# 5 Заключение

